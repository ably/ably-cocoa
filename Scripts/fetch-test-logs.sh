#!/bin/bash

# Retrieves the raw xcodebuild output for one or more test observability server
# uploads.
#
# Only works for tests that were run using the
# continuously-run-tests-and-upload-results script in this directory.

# Usage:
# ./fetch-test-logs.sh --repo ably/ably-cocoa --test-case-id <id> --filter [filter]
#
# or
#
# ./fetch-test-logs.sh --repo ably/ably-cocoa --upload-id <id>

# Options:
#
# -r / --repo <name>: The 'org/name'-formatted name of the GitHub repo, for
# example 'ably/ably-cocoa'.
#
# -t / --test-case-id <id>: The ID of a test case saved on the test
# observability server. Will fetch all uploads that match the filter specified
# using the --filter option, and then save the results inside the directory
# specified by the --output-directory option, in the following hierarchy, where
# uploads are split into those where the test case failed and those where it
# didn’t (which doesn’t necessarily imply that the test case passed; it may not
# have run at all):
#
# <output directory>
# ├── info.json (contains metadata about the results in this directory)
# ├── upload_logs
# │   ├── failed
# │   │   └── xcodebuild-logs-upload-<upload ID>, ...
# │   └── not_failed
# │       └── xcodebuild-logs-upload-<upload ID>, ...
# └── test-case-logs (unless --no-extract-test-case-logs specified)
#     ├── failed
#     │   └── xcodebuild-logs-upload-<upload ID>, ...
#     └── not_failed
#         └── xcodebuild-logs-upload-<upload ID>, ...
#
# The upload_logs directory contains the full logs for that upload, and the
# test_case_logs directory contains just the segments of the logs that
# correspond to the specific test case.
#
# -d / --output-directory <dir>: Where to output the logs generated by the
# --test-case-id option to. Defaults to ./xcodebuild-logs-test-case-<test case ID>-<current datetime>.
#
# -f / --filter <filter>: A URL query string describing a filter to be applied
# to the uploads fetched when using the --test-case-id option. For example,
# "branches[]=main&createdBefore=2022-02-20".
#
# -n / --no-extract-test-case-logs: Will cause the --test-case-id option to not
# attempt to extract the segment of the upload log that corresponds to the test
# case.
#
# -i / --upload-id <id>: The ID of a upload saved on the test observability
# server.
#
# -u / --upload-server-base-url <url>: Allows you to specify a URL to use as
# the upload server base URL. Defaults to https://test-observability.herokuapp.com.
#
# -o / --output-file <file>: Where to output the logs generated by the
# --upload-id option to. Defaults to ./xcodebuild-logs-upload-<upload ID>.
#
# -c / --cache-directory <dir>: Where to cache the GitHub logs. Defaults to
# ~/Library/Caches/com.ably.testObservabilityLogs. Will be created if doesn’t
# exist.
#
# -a / --no-use-github-auth: Will not prompt the user for an access token to be
# used for making requests to the GitHub API. Useful if all the required GitHub
# job logs are already cached locally.

set -e

check_dependencies() {
  if ! which jq >/dev/null; then
    echo "You need to install jq." 2>&1
    exit 1
  fi
}

get_github_access_token() {
  # https://stackoverflow.com/questions/3980668/how-to-get-a-password-from-a-shell-script-without-echoing#comment4260181_3980904
  read -s -p "Enter your GitHub access token (this will be used to fetch logs from the GitHub API): " github_access_token

  echo

  if [[ -z $github_access_token ]]; then
    echo "You need to specify a GitHub access token." 2>&1
    exit 1
  fi

  echo
}

# Args:
# $1: JSON representation of the test observability server upload
# $2: Path to write the logs to
fetch_and_write_logs_for_upload() {
  upload_json=$1
  output_file=$2

  # (TIL I learned that `echo` will interpret backslash sequences, which we
  # don’t want.  Appparently in general printf is recommended over echo.)
  # https://stackoverflow.com/questions/43528202/prevent-echo-from-interpreting-backslash-escapes
  github_repository=$(printf '%s' $upload_json | jq --raw-output '.githubRepository')
  github_run_id=$(printf '%s' $upload_json | jq --raw-output '.githubRunId')
  github_run_attempt=$(printf '%s' $upload_json | jq --raw-output '.githubRunAttempt')
  github_job=$(printf '%s' $upload_json | jq --raw-output '.githubJob')
  iteration=$(printf '%s' $upload_json | jq --raw-output '.iteration')

  echo "Upload comes from GitHub repository ${github_repository}. It has GitHub run ID ${github_run_id}, run attempt number ${github_run_attempt}, and job name ${github_job}. It corresponds to loop iteration ${iteration}."

  # Check whether we have a cached log for this job.
  # (We cache the job logs because when running the tests continuously, with
  # verbose logging enabled, a job log can be ~1.5GB.)

  log_file_name="github-log-${github_repository//\//-}-run-${github_run_id}-attempt-${github_run_attempt}-job-${github_job}"
  log_file_path="${cache_directory}/${log_file_name}"

  if [[ -f "${log_file_path}" ]]; then
    echo "GitHub job log file already exists at ${log_file_path}. Skipping download." 2>&1
  else
    echo "GitHub job log file not yet downloaded." 2>&1

    # (I wonder if this information that I’m fetching from GitHub is stuff that
    # I should have just had in the upload in the first place? Not that
    # important right now.)

    github_api_base_url="https://api.github.com"

    # From the GitHub API, fetch the jobs for this workflow run attempt.
    # https://docs.github.com/en/rest/reference/actions#list-jobs-for-a-workflow-run-attempt
    github_jobs_json=$(curl \
      --fail \
      -H "Accept: application/vnd.github.v3+json" \
      "${github_auth_curl_args[@]}" \
      "${github_api_base_url}/repos/${github_repository}/actions/runs/${github_run_id}/attempts/${github_run_attempt}/jobs")

    # From this list of jobs, find the one that corresponds to our upload.
    github_job_id=$(printf "%s" $github_jobs_json | jq \
      --arg jobName "${github_job}" \
      '.jobs[] | select(.name == $jobName) | .id')

    if [[ -z $github_job_id ]]; then
      echo "Could not find job with name ${github_job} in attempt ${github_run_attempt} of run ${github_run_id} in GitHub repository ${github_repository}." 2>&1
      exit 1
    fi

    echo "Upload corresponds to GitHub job ID ${github_job_id}. Downloading logs. This may take a while."

    # From the GitHub API, fetch the logs for this job and cache them.
    # https://docs.github.com/en/rest/reference/actions#download-job-logs-for-a-workflow-run

    if [[ ! -d "${cache_directory}" ]]; then
      mkdir -p "${cache_directory}"
    fi

    curl \
      --fail \
      --location \
      -H "Accept: application/vnd.github.v3+json" \
      "${github_auth_curl_args[@]}" \
      "${github_api_base_url}/repos/${github_repository}/actions/jobs/${github_job_id}/logs" >"${log_file_path}.partial"

    mv "${log_file_path}.partial" "${log_file_path}"

    echo "Saved GitHub job logs to ${log_file_path}."
  fi

  # Extract the part of the logs that corresponds to the raw xcodebuild output for this iteration.
  # https://stackoverflow.com/a/18870500

  echo "Finding xcodebuild output for iteration ${iteration}."

  xcodebuild_output_start_marker="ITERATION ${iteration}: BEGIN xcodebuild raw output"
  xcodebuild_output_start_line_number=$(sed -n "/${xcodebuild_output_start_marker}/=" "${log_file_path}")

  if [[ -z "${xcodebuild_output_start_line_number}" ]]; then
    echo "Couldn’t find start of xcodebuild raw output (couldn’t find marker \"${xcodebuild_output_start_marker}\")." 2>&1
    echo "This may be because the GitHub job hasn’t finished yet, or because the tests are not being run in a loop, or it may be an upload created before this functionality was implemented." 2>&1
    echo "You may need to delete the cached log file ${log_file_path}." 2>&1
    exit 1
  fi

  xcodebuild_output_end_marker="ITERATION ${iteration}: END xcodebuild raw output"
  xcodebuild_output_end_line_number=$(sed -n "/${xcodebuild_output_end_marker}/=" "${log_file_path}")

  if [[ -z "${xcodebuild_output_end_line_number}" ]]; then
    echo "Couldn’t find end of xcodebuild raw output (couldn’t find marker \"${xcodebuild_output_end_marker}\")." 2>&1
    exit 1
  fi

  # Strip the GitHub-added timestamps (which just correspond to the time that `cat` was executed on the log file, and hence aren’t of any use) from the start of each line.

  echo "Stripping GitHub timestamps."

  # https://arkit.co.in/print-given-range-of-lines-using-awk-perl-head-tail-and-python/
  sed -n "${xcodebuild_output_start_line_number},${xcodebuild_output_end_line_number} p" "${log_file_path}" | sed -e 's/^[^ ]* //' >"${output_file}"

  echo "Wrote xcodebuild output to ${output_file}." 2>&1
}

default_output_file_for_upload_id() {
  echo "xcodebuild-logs-upload-$1"
}

run_for_test_case() {
  # From the test observability server API, fetch the test case and extract its
  # properties.

  echo "Fetching test case ${test_case_id} from ${upload_server_base_url}." 2>&1

  test_case_json=$(curl --fail --header "Accept: application/json" "${upload_server_base_url}/repos/${repo}/test_cases/${test_case_id}")

  test_class_name=$(printf '%s' $test_case_json | jq --raw-output '.testClassName')
  test_case_name=$(printf '%s' $test_case_json | jq --raw-output '.testCaseName')

  printf "Test case ${test_case_id} has test class name ${test_class_name} and test case name ${test_case_name}.\n\n"

  # From the test observability server API, fetch the filtered uploads.

  if [[ -z $filter ]]; then
    filter_description="no filter"
    filter_query=""
  else
    filter_description="filter ${filter}"
    filter_query="?${filter}"
  fi

  echo "Fetching uploads for test case ${test_case_id}, with ${filter_description}, from ${upload_server_base_url}." 2>&1

  uploads_json=$(curl --fail --header "Accept: application/json" "${upload_server_base_url}/repos/${repo}/test_cases/${test_case_id}/uploads${filter_query}")

  number_of_uploads=$(printf '%s' $uploads_json | jq '. | length')

  if [[ ${number_of_uploads} -eq 1 ]]; then
    echo "There is 1 upload". 2>&1
  else
    echo "There are ${number_of_uploads} uploads". 2>&1
  fi

  echo

  mkdir "${output_directory}"
  mkdir "${output_directory}/upload_logs"
  mkdir "${output_directory}/test_case_logs"

  failed_upload_logs_output_directory="${output_directory}/upload_logs/failed"
  mkdir "${failed_upload_logs_output_directory}"
  not_failed_upload_logs_output_directory="${output_directory}/upload_logs/not_failed"
  mkdir "${not_failed_upload_logs_output_directory}"

  failed_test_case_logs_output_directory="${output_directory}/test_case_logs/failed"
  mkdir "${failed_test_case_logs_output_directory}"
  not_failed_test_case_logs_output_directory="${output_directory}/test_case_logs/not_failed"
  mkdir "${not_failed_test_case_logs_output_directory}"

  jq -n \
    --arg testCaseId "${test_case_id}" \
    --arg filter "${filter}" \
    --arg uploadServerBaseUrl "${upload_server_base_url}" \
    '{ fetchedAt: (now | todateiso8601), testCaseId: $testCaseId, filter: $filter, uploadServerBaseUrl: $uploadServerBaseUrl }' \
    >"${output_directory}/info.json"

  for ((i = 0; i < number_of_uploads; i += 1)); do
    failed=$(printf '%s' $uploads_json | jq ".[${i}].failed")
    upload_json=$(printf '%s' $uploads_json | jq ".[${i}].upload")

    upload_id=$(printf '%s' $upload_json | jq --raw-output '.id')

    echo "[$((i + 1)) of ${number_of_uploads}] Processing upload ${upload_id}." 2>&1

    output_file_without_directory=$(default_output_file_for_upload_id "${upload_id}")

    if [[ $failed == "true" ]]; then
      upload_log_output_file="${failed_upload_logs_output_directory}/${output_file_without_directory}"
      test_case_log_output_file="${failed_test_case_logs_output_directory}/${output_file_without_directory}"
    else
      upload_log_output_file="${not_failed_upload_logs_output_directory}/${output_file_without_directory}"
      test_case_log_output_file="${not_failed_test_case_logs_output_directory}/${output_file_without_directory}"
    fi

    fetch_and_write_logs_for_upload "${upload_json}" "${upload_log_output_file}"

    if [[ -z "${no_extract_test_case_logs}" ]]; then
      extract_logs_for_test_case "${test_class_name}" "${test_case_name}" "${upload_log_output_file}" "${test_case_log_output_file}"
    fi

    echo
  done
}

# Args:
# $1: Test class name e.g. RealtimeClientPresenceTests
# $2: Test case name e.g. test__037__Presence__update__should_update_the_data_for_the_present_member_with_a_value()
# $3: Path of the xcodebuild logs for the entire test suite run
# $4: Path of where to write the test case logs to.
extract_logs_for_test_case() {
  # Extract the part of the logs that corresponds to the raw xcodebuild output for this iteration. (We have similar code in fetch_and_write_logs_for_upload.)

  test_class_name=$1
  test_case_name=$2
  upload_log_file=$3
  output_file=$4

  # (For some reason, the test case name in the observability server has
  # trailing (), but in the xcodebuild logs it doesn’t. So strip them.)
  sanitised_test_case_name="${test_case_name//[()]/}"

  echo "Finding logs for test class ${test_class_name}, test case ${test_case_name} in ${upload_log_file}." 2>&1

  test_case_log_start_marker="Test Case.*${test_class_name} ${sanitised_test_case_name}.*started"
  test_case_log_start_line_number=$(sed -n "/${test_case_log_start_marker}/=" "${upload_log_file}")

  if [[ -z "${test_case_log_start_line_number}" ]]; then
    echo "Couldn’t find start of test case output (couldn’t find marker \"${test_case_log_start_marker}\")." 2>&1
    exit 1
  fi

  test_case_log_end_marker="Test Case.*${test_class_name} ${sanitised_test_case_name}.*(passed|failed)|Restarting after unexpected exit, crash, or test timeout in ${test_class_name}\/${sanitised_test_case_name}\(\)"
  test_case_log_end_line_number=$(sed -En "/${test_case_log_end_marker}/=" "${upload_log_file}")

  if [[ -z "${test_case_log_end_line_number}" ]]; then
    echo "Couldn’t find end of test case output (couldn’t find marker \"${test_case_log_end_marker}\")." 2>&1
    exit 1
  fi

  sed -n "${test_case_log_start_line_number},${test_case_log_end_line_number} p" "${upload_log_file}" >"${output_file}"

  echo "Wrote test case log to ${output_file}." 2>&1
}

run_for_upload() {
  # From the test observability server API, fetch the upload, to find the
  # GitHub run ID, attempt number, job name, and iteration.

  echo "Fetching upload ${upload_id} from ${upload_server_base_url}." 2>&1

  upload_json=$(curl --fail --header "Accept: application/json" "${upload_server_base_url}/repos/${repo}/uploads/${upload_id}")

  fetch_and_write_logs_for_upload "${upload_json}" "${output_file}"
}

check_dependencies

# Grab and validate command-line options, and apply defaults.

# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
while [[ "$#" -gt 0 ]]; do
  case $1 in
    -r | --repo)
      repo="$2"
      shift
      ;;
    -t | --test-case-id)
      if [[ -z "$2" ]]; then
        echo "You must specify a test case ID when using the --test-case-id option." 2>&1
        exit 1
      fi
      test_case_id="$2"
      shift
      ;;
    -d | --output-directory)
      if [[ -z "$2" ]]; then
        echo "You must specify an output directory when using the --output-directory option." 2>&1
        exit 1
      fi
      output_directory="$2"
      shift
      ;;
    -f | --filter)
      if [[ -z "$2" ]]; then
        echo "You must specify a filter when using the --filter option." 2>&1
        exit 1
      fi
      filter="$2"
      shift
      ;;
    -n | --no-extract-test-case-logs) no_extract_test_case_logs="1" ;;
    -i | --upload-id)
      if [[ -z "$2" ]]; then
        echo "You must specify an upload ID when using the --upload-id option." 2>&1
        exit 1
      fi
      upload_id="$2"
      shift
      ;;
    -u | --upload-server-base-url)
      if [[ -z "$2" ]]; then
        echo "You must specify a base URL when using the --upload-server-base-url option." 2>&1
        exit 1
      fi
      upload_server_base_url="$2"
      shift
      ;;
    -o | --output-file)
      if [[ -z "$2" ]]; then
        echo "You must specify an output file when using the --output-file option." 2>&1
        exit 1
      fi
      output_file="$2"
      shift
      ;;
    -c | --cache-directory)
      if [[ -z "$2" ]]; then
        echo "You must specify a cache directory when using the --cache-directory option." 2>&1
        exit 1
      fi
      cache_directory="$2"
      shift
      ;;
    -a | --no-use-github-auth) no_use_github_auth="1" ;;
    *)
      echo "Unknown parameter passed: $1" 2>&1
      exit 1
      ;;
  esac
  shift
done

if [[ -z $repo ]]; then
  echo "You need to specify a repo (-r / --repo)." 2>&1
  exit 1
fi

if [[ -z $test_case_id && -z $upload_id ]]; then
  echo "You need to specify the test case ID (-t / --test-case-id) or upload ID (-i / --upload-id)." 2>&1
  exit 1
fi

if [[ -n $test_case_id && -n $upload_id ]]; then
  echo "You cannot specify both a test case ID and an upload ID." 2>&1
  exit 1
fi

if [[ -n $test_case_id && -n $upload_id ]]; then
  echo "You cannot specify both a test case ID and an upload ID." 2>&1
  exit 1
fi

if [[ -z $test_case_id && -n $output_directory ]]; then
  echo "You can only specify an output directory with a test case ID (-t / --test-case-id)." 2>&1
  exit 1
fi

if [[ -z $output_directory ]]; then
  output_directory="xcodebuild-logs-test-case-${test_case_id}-$(date -Iseconds)"
fi

if [[ -z $test_case_id && -n $filter ]]; then
  echo "You can only specify a filter with a test case ID (-t / --test-case-id)." 2>&1
  exit 1
fi

if [[ -z $test_case_id && -n $no_extract_test_case_logs ]]; then
  echo "You can only specify the --no-extract-test-case-logs option with a test case ID (-t / --test-case-id)." 2>&1
  exit 1
fi

if [[ -z $upload_server_base_url ]]; then
  upload_server_base_url="https://test-observability.herokuapp.com"
fi

if [[ -z $upload_id && -n $output_file ]]; then
  echo "You can only specify an output file with an upload ID (-i / --upload-id)." 2>&1
  exit 1
fi

if [[ -z $output_file ]]; then
  output_file=$(default_output_file_for_upload_id "${upload_id}")
fi

if [[ -z $cache_directory ]]; then
  cache_directory="${HOME}/Library/Caches/com.ably.testObservabilityLogs"
fi

github_auth_curl_args=()
if [[ -z $no_use_github_auth ]]; then
  # Get the GitHub access token from the user. We don’t allow them to specify it on the command line.
  github_access_token=""
  get_github_access_token
  github_auth_curl_args+=(-H "Authorization: token ${github_access_token}")
fi

# Run the appropriate function based on arguments.

if [[ -n $test_case_id ]]; then
  run_for_test_case
elif [[ -n $upload_id ]]; then
  run_for_upload
fi
