# Contributing

## Requirements

- The Xcode version [mentioned in the README](./README.md#requirements)
- [Mint](https://github.com/yonaskolb/Mint) package manager
- Node.js (any recent version should be fine)

## Setup

1. `git submodule update --init`
2. `mint bootstrap` — this will take quite a long time (~5 minutes on my machine) the first time you run it
3. `npm install`

## Running the tests

Either:

- `swift test`, or
- open `AblyLiveObjects.xcworkspace` in Xcode and test the `AblyLiveObjects` scheme

### Running only the unit tests

There is a test plan called `UnitTests` which will run only the unit tests. These tests are very quick to execute, so it's a useful option to have for quick feedback when developing.

Here's how to set this test plan as the _active test plan_ (the test plan which ⌘U will run):

![Screenshot showing how to activate the UnitTests test plan](/images/unit-tests-test-plan-screenshot.png)

## Linting

To check formatting and code quality, run `swift run BuildTool lint`. Run with `--fix` to first automatically fix things where possible.

## Development guidelines

- The aim of the [example app](README.md#example-app) is that it demonstrate all of the core functionality of the SDK. So if you add a new feature, try to add something to the example app to demonstrate this feature.
- If you add a new feature, try to extend the `IntegrationTests` tests to perform a smoke test of its core functionality.
- We should aim to make it easy for consumers of the SDK to be able to mock out the SDK in the tests for their own code. A couple of things that will aid with this:
  - Describe the SDK’s functionality via protocols (when doing so would still be sufficiently idiomatic to Swift).
  - When defining a `struct` that is emitted by the public API of the library, make sure to define a public memberwise initializer so that users can create one to be emitted by their mocks. (There is no way to make Swift’s autogenerated memberwise initializer public, so you will need to write one yourself. In Xcode, you can do this by clicking at the start of the type declaration and doing Editor → Refactor → Generate Memberwise Initializer.)
- When writing code that implements behaviour specified by the LiveObjects features spec, add a comment that references the identifier of the relevant spec item.
- When writing methods that accept one of the public callback types (e.g. `LiveObjectUpdateCallback`), use the typealias name instead of the resolved type that Xcode fills in autocomplete; that is, write `LiveObjectUpdateCallback<LiveCounterUpdate>` instead of autocomplete's `(any LiveCounterUpdate) -> Void`.

### Throwing errors

- The public API of the SDK should use typed throws, and the thrown errors should be of type `ARTErrorInfo`.
- Some platform methods do not support typed throws. In these cases, we have our own extension which does; use this instead. They are:
  - `Dictionary.mapValues`; use `ablyLiveObjects_mapValuesWithTypedThrow`.
  - `NSLock.withLock`; use `ablyLiveObjects_withLockWithTypedThrow`.

### Memory management

We follow an approach to memory management that is broadly similar to that of ably-cocoa: we keep all of the internal components of the SDK alive as long as the user is holding a strong reference to any object vended by the public API of the SDK. This means that, for example, a user can use LiveObjects functionality by maintaining only a reference to the root `LiveMap`; even if they relinquish their references to, say, the `ARTRealtime` or `ARTRealtimeChannel` instance, they will continue to receive events from the `LiveMap` and they will be able to use its methods.

We achieve this by vending a set of public types which maintain strong references to all of the internal components of the SDK which are needed in order for the public type to function correctly. For example, the public `PublicDefaultLiveMap` type wraps an `InternalDefaultLiveMap`, and holds strong references to the `CoreSDK` object, which in turn holds the following sequence of strong references: `CoreSDK` → `RealtimeClient` → `RealtimeChannel` → `InternalDefaultRealtimeObjects`, thus ensuring that:

1. the `InternalDefaultLiveMap` can always perform actions on these dependencies in response to a user action
2. these dependencies, which deliver events to the `InternalDefaultLiveMap`, remain alive and thus remain delivering events

The key rules that must be followed in order to avoid a strong reference cycle are that the SDK's _internal_ classes (that is `InternalDefaultLiveMap` etc) _must never hold a strong reference to_:

- any of the corresponding public types (e.g. `PublicDefaultLiveMap`)
- any of the ably-cocoa components that hold a strong reference to these internal components (that is, the realtime client or channel); thus, they must never hold a strong reference to a `CoreSDK` object

Note that, unlike ably-cocoa, the internal components do not even hold weak references to their dependencies; rather, these dependencies are passed in by the public object when the user performs an action that requires one of these dependencies. (There may turn out to be limitations to this approach, but haven't found them yet.)

Also note that, unlike ably-cocoa, we aim to provide a stable pointer identity for the public objects vended by the SDK, instead of creating a new object each time the user requests one. See the `PublicObjectsStore` class for more details.

The `Public…` classes all follow the same pattern and are not very interesting; the business logic should be in the `Internal…` classes and those should be where we focus our unit testing effort.

`ObjectLifetimesTests.swift` contains tests of the behaviour described in this section.

### Testing guidelines

#### Attributing tests to a spec point

When writing a test that relates to a spec point from the LiveObjects features spec, add a comment that contains one of the following tags:

- `@spec <spec-item-id>` — The test case directly tests all the functionality documented in the spec item.
- `@specOneOf(m/n) <spec-item-id>` — The test case is the m<sup>th</sup> of n test cases which, together, test all the functionality documented in the spec item.
- `@specPartial <spec-item-id>` — The test case tests some, but not all, of the functionality documented in the spec item. This is different to `@specOneOf` in that it implies that the test suite does not fully test this spec item.

The `<spec-item-id>` parameter should be a spec item identifier such as `CHA-RL3g`.

Each of the above tags can optionally be followed by a hyphen and an explanation of how the test relates to the given spec item.

Examples:

```swift
// @spec CHA-EX3f
func test1 { … }
```

```swift
// @specOneOf(1/2) CHA-EX2h — Tests the case where the room is FAILED
func test2 { … }

// @specOneOf(2/2) CHA-EX2h — Tests the case where the room is SUSPENDED
func test3 { … }
```

```swift
// @specPartial CHA-EX1h4 - Tests that we retry, but not the retry attempt limit because we’ve not implemented it yet
func test4 { … }
```

You can run `swift run BuildTool spec-coverage` to generate a report about how many spec points have been implemented and/or tested. This script is also run in CI by the `spec-coverage` job. This script will currently only detect a spec point attribution tag if it’s written exactly as shown above; that is, in a `//` comment with a single space between each component of the tag.

#### Marking a spec point as untested

In addition to the above, you can add the following as a comment anywhere in the test suite:

- `@specUntested <spec-item-id> - <explanation>` — This indicates that the SDK implements the given spec point, but that there are no automated tests for it. This should be used sparingly; only use it when there is no way to test a spec point. It must be accompanied by an explanation of why this spec point is not tested.
- `@specNotApplicable <spec-item-id> - <explanation>` — This indicates that the spec item is not relevant for this version of the SDK. It must be accompanied by an explanation of why.

Example:

```swift
// @specUntested CHA-EX2b - I was unable to find a way to test this spec point in an environment in which concurrency is being used; there is no obvious moment at which to stop observing the emitted state changes in order to be sure that FAILED has not been emitted twice.
```

```swift
// @specNotApplicable CHA-EX3a - Our API does not have a concept of "partial options" unlike the JS API which this spec item considers.
```

## Developing ably-cocoa alongside this plugin

For the initial stage of development of this plugin, where we need to also iterate heavily on ably-cocoa, I've added ably-cocoa as a Git submodule, which can be found in [`ably-cocoa`](./ably-cocoa). This allows you to edit ably-cocoa from within this repo's Xcode workspace.

Nearer launch, we'll remove this submodule in https://github.com/ably/ably-liveobjects-swift-plugin/issues/7.

## Release process

For each release, the following needs to be done:

- Create a new branch `release/x.x.x` (where `x.x.x` is the new version number) from the `main` branch
- Update the following (we have https://github.com/ably/ably-chat-swift/issues/277 for adding a script to do this):
  - the `version` constant in [`Sources/AblyLiveObjects/Version.swift`](Sources/AblyLiveObjects/Version.swift)
  - the `from: "…"` in the SPM installation instructions in [`README.md`](README.md)
- Go to [Github releases](https://github.com/ably/ably-liveobjects-swift-plugin/releases) and press the `Draft a new release` button. Choose your new branch as a target
- Press the `Choose a tag` dropdown and start typing a new tag, Github will suggest the `Create new tag x.x.x on publish` option. After you select it Github will unveil the `Generate release notes` button
- From the newly generated changes remove everything that don't make much sense to the library user
- Copy the final list of changes to the top of the `CHANGELOG.md` file. Modify as necessary to fit the existing format of this file
- Commit these changes and push to the origin `git add CHANGELOG.md && git commit -m "Update change log." && git push -u origin release/x.x.x`
- Make a pull request against `main` and await approval of reviewer(s)
- Once approved and/or any additional commits have been added, merge the PR
- After merging the PR, wait for all CI jobs for `main` to pass.
- Publish your drafted release (refer to previous releases for release notes format)
